# 变量

:::details 参考资料：

- [8小时转职Golang工程师](https://www.bilibili.com/video/BV1gf4y1r79E)
- [8小时转职Golang工程师，语雀文档](https://www.yuque.com/aceld/mo95lb)
- [Golang中文学习文档站](https://golang.halfiisland.com/)

:::

变量是用于保存一个值的存储位置，允许其存储的值在运行时动态的变化。

每声明一个变量，都会为其分配一块内存以存储对应类型的值，[参考手册-变量](https://go.dev/ref/spec#Variables) 查看更多细节。

## 1、声明

在 go 中的类型声明是后置的，变量的声明会用到 `var` 关键字，格式为：

````go
var 变量名 类型名
````

变量名的命名规则必须遵守标识符的命名规则：

````go
var intNum int
var str string
var char byte
````

在 go 语言中，声明变量的一般形式是使用 `var` 关键字，有四种方式：

````go
func main() {
	// 方式一：声明一个变量，默认的值是0
	var a int
	fmt.Println("a = ", a)
	fmt.Printf("tyoe of a = %T\n", a)

	// 方式二：声明一个变量，初始化一个值
	var b int = 100
	fmt.Println("b = ", b)
	fmt.Printf("tyoe of b = %T\n", b)

	// 方法三：初始化的时候, 省去数据类型，通过值自动匹配当前的变量的数据类型
	var c = 100
	fmt.Println("c = ", c)
	fmt.Printf("tyoe of c = %T\n", c)

	// 方法四：(常用) 省去var关键字，直接自动匹配
	d := 100
	fmt.Println("d = ", d)
	fmt.Printf("tyoe of d = %T\n", d)
}
````

常见的格式化占位符：

- `%T` ： 会输出传入变量的数据类型
- `%s` ：打印字符串
- `%f` ：打印浮点数
- `%v` ：打印变量的值，是一个通用占位符，适用于多种类型

这些转义字符用于在字符串中嵌入无法直接输入的字符或控制字符。

上述四种方式都可以声明局部变量，但是**全局变量只能由前三种方式声明**。

当要声明多个不同类型的变量时，可以使用()进行包裹，可以存在多个()：

````go
func main() {
	// 声明多个变量
	var xx, yy int = 100, 200
	var s1, s2 string = "hello", "world"
	fmt.Println("xx= ", xx, ", yy= ", yy, ", s1= ", s1, ", s2= ", s2)

	// 多变量声明，多行
	var (
		cc int     = 100
		dd float32 = 3.14
		ee bool    = true
	)
	fmt.Println("cc= ", cc, ", dd= ", dd, ", ee= ", ee)
}
````

一个变量如果只是声明而不赋值，那么变量存储的值就是对应类型的零值。

## 2、赋值

赋值会用到运算符 `=` ：

````go
var name string
name = "jack"
````

也可以声明的时候直接赋值:

````go
var name string = "jack"
````

或者官方提供的语法糖，省略掉var关键字和后置类型，具体是什么类型交给编译器自行推断：

````go
name := "jack" // 字符串类型的变量。
````

虽然可以不用指定类型，但是在后续赋值时，类型必须保持一致，否则下面这种代码无法通过编译：

````go
a := 1
a = "1"
````

短变量初始化不能使用nil，因为nil不属于任何类型，编译器无法推断其类型。

短变量声明也可以批量初始化：

````go
name, age := "jack", 1
````

短变量声明方式无法对一个已存在的变量使用。

但是有一种情况除外，那就是在赋值旧变量的同时声明一个新的变量：

````go
a := 1
a, b := 2, 2
````

这种代码是可以通过编译的，变量a被重新赋值，而b是新声明的。

在 go 语言中，有一个规则，那就是所有在函数中的变量都必须要被使用，比如下面的代码只是声明了变量，但没有使用它：

````go
func main() {
  a := 1
}
````

那么在编译时就会报错，提示你这个变量声明了但没有使用

````
a declared and not used
````

这个规则仅适用于函数内的变量，对于函数外的包级变量则没有这个限制。

## 3、匿名

用下划线可以表示不需要某一个变量

````go
// 返回值： (*File, error)
Open(name string) (*File, error)
````

比如 os.Open 函数有两个返回值，我们只想要第一个，不想要第二个，可以按照下面这样写：

````go
file, _ := os.Open("readme.txt")
````

未使用的变量是无法通过编译的，当你不需要某一个变量时，就可以使用下划线 `_` 代替。

## 4、交换

在 Go 中，如果想要交换两个变量的值，不需要使用指针，可以使用赋值运算符直接进行交换，语法上看起来非常直观：

````go
num1, num2 := 25, 36
num1, num2 = num2, num1
````

三个变量也是同样如此：

````go
num1, num2, num3 := 25, 36, 49
num1, num2, num3  = num3, num2, num1
````

思考下面这一段代码，这是计算斐波那契数列的一小段代码，三个变量在计算后的值分别是什么：

````go
a, b, c := 0, 1, 1
a, b, c = b, c, a+b
````

答案是：

````
1 1 1
````

明明 a 已经被赋予 b 的值了，为什么 a+b 的结果还是 1？go 在进行多个变量赋值运算时，它的顺序是先计算值再赋值，并非从左到右计算。

当涉及到函数调用时，这个效果就更为明显，我们有一个函数sum可以计算两个数字的返回值

````go
func sum(a, b int) int {
  return a + b
}
````

通过函数来进行两数相加：

````go
a, b, c := 0, 1, 1
a, b, c = b, c, sum(a, b)
````

结果没有变化，在计算sum函数返回值时，它的入参依旧是 0 和 1。

所以代码应该这样分开写：

````go
a, b = b, c
c = a + b
````

## 5、比较

变量之间的比较有一个大前提，那就是它们之间的类型必须相同，go 语言中不存在隐式类型转换:

````go
func main() {
  var a uint64
  var b int64
  fmt.Println(a == b)
}
````

编译器会告诉你两者之间类型并不相同：

````
invalid operation: a == b (mismatched types uint64 and int64)
````

必须使用强制类型转换：

````go
func main() {
  var a uint64
  var b int64
  fmt.Println(int64(a) == b)
}
````

go 中的可比较类型有：

- 布尔
- 数字
- 字符串
- 指针
- 通道 （仅支持判断是否相等）
- 元素是可比较类型的数组（切片不可比较）（仅支持判断是否相等）（仅支持相同长度的数组间的比较，因为数组长度也是类型的一部分，而不同类型不可比较）
- 字段类型都是可比较类型的结构体（仅支持判断是否相等）

## 6、代码块

在函数内部，可以通过花括号建立一个代码块，代码块彼此之间的变量作用域是相互独立的：

````go
func main() {
  a := 1

  {
    a := 2
    fmt.Println(a)
  }

  {
    a := 3
    fmt.Println(a)
  }
  fmt.Println(a)
}
````

块与块之间的变量相互独立，不受干扰，无法访问，但是会受到父块中的影响。