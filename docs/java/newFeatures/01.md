# 函数伊始

::: details 参考资料：

- [黑马程序员Java函数式编程全套视频教程](https://www.bilibili.com/video/BV1fz421C7tj)

:::

## 函数

### 1、合格的函数

「函数」就是一种规则，定义好输入，会有输出；并且，合格的函数是，无论经过多少次调用，输入相同则输出结果也相同。

例如：

````java
// 合格的函数
public class Sample01 {
    public static void main(String[] args) {
        System.out.println(square(10));
        System.out.println(square(10));
        System.out.println(square(10));
        System.out.println(square(10));
        System.out.println(square(10));
        System.out.println(square(10));
    }

    private static int square(int x) {
        return x * x;
    }
}
````

由于设计上的缺陷，函数引用了外界可变的数据，就会导致函数执行的结果发生改变

````java
public class Sample02 {
    public static void main(String[] args) {
        System.out.println(pray("张三"));
        System.out.println(pray("张三"));
        System.out.println(pray("张三"));
        System.out.println(pray("张三"));
        buddha.name = "devil";
        System.out.println(pray("张三"));
    }

    static class Buddha{
        String name;

        public Buddha(String name){
            this.name = name;
        }
    }

    static Buddha buddha = new Buddha("如来");

    static String pray(String person){
        return person + "向[" + buddha.name + "]求佛";
    }
}
````

佛祖要成为规则的一部分，也要保持不变，改正方法：

````java
static class Buddha {
    final String name;

    public Buddha(String name) {
        this.name = name;
    }
}
````

* 不是说函数不能引用外界的数据，而是它引用的数据必须也能作为规则的一部分
* 让佛祖不变，佛祖才能成为规则

「方法」本质上也是函数，不过方法绑定在对象之上，它是**对象个人法则**。

### 2、有形的函数

函数本无形，也就是它代表的规则：位置固定、不能传播。若要有形，让函数的规则能够传播，需要将函数化为对象。

````java
public class Sample03 {
    // 有形的函数
    static int add(int a, int b) {
        return a + b;
    }

    interface Calculator {
        int calculate(int a, int b);
    }

    // 函数化为对象
    static Calculator add = (a, b) -> a + b;

    /**
     * 前者是纯粹的一条两数加法规则，它的位置是固定的，要使用它，需要通过 Sample03.add 找到它，然后执行
     * 而后者（add 对象）就像长了腿，它的位置是可以变化的，想去哪里就去哪里，哪里要用到这条加法规则，把它传递过去
     * 接口的目的是为了将来用它来执行函数对象，此接口中只能有一个方法定义
     */
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        System.out.println(Sample03.add(a, b));

        System.out.println(add(a, b));
    }
}
````

不同的客户端可以上传自己的计算规则：

````java
public class Sample04 {
    interface Lambda {
        int calculate(int a, int b);
    }

    /**
     * 创建一个服务器，接收客户端传来的Lambda对象，并计算结果
     */
    static class Server {
        public static void main(String[] args) throws IOException {
            ServerSocket ss = new ServerSocket(8080);
            System.out.println("server start...");
            while (true) {
                Socket s = ss.accept();
                Thread.ofVirtual().start(() -> {
                    try {
                        ObjectInputStream is = new ObjectInputStream(s.getInputStream());
                        Lambda lambda = (Lambda) is.readObject();
                        int a = ThreadLocalRandom.current().nextInt(10);
                        int b = ThreadLocalRandom.current().nextInt(10);
                        System.out.printf("%s %d op %d = %d%n",
                                s.getRemoteSocketAddress().toString(), a, b, lambda.calculate(a, b));
                    } catch (IOException | ClassNotFoundException e) {
                        throw new RuntimeException(e);
                    }
                });
            }
        }
    }

    /**
     * 客户端发送一个Lambda对象给服务器
     */
    static class Client1 {
        public static void main(String[] args) throws IOException {
            try(Socket s = new Socket("127.0.0.1", 8080)){
                Lambda lambda = (Lambda & Serializable) (a, b) -> a + b;
                ObjectOutputStream os = new ObjectOutputStream(s.getOutputStream());
                os.writeObject(lambda);
                os.flush();
            }
        }
    }


    static class Client2 {
        public static void main(String[] args) throws IOException {
            try(Socket s = new Socket("127.0.0.1", 8080)){
                Lambda lambda = (Lambda & Serializable) (a, b) -> a - b;
                ObjectOutputStream os = new ObjectOutputStream(s.getOutputStream());
                os.writeObject(lambda);
                os.flush();
            }
        }
    }

    static class Client3 {
        public static void main(String[] args) throws IOException {
            try(Socket s = new Socket("127.0.0.1", 8080)){
                Lambda lambda = (Lambda & Serializable) (a, b) -> a * b;
                ObjectOutputStream os = new ObjectOutputStream(s.getOutputStream());
                os.writeObject(lambda);
                os.flush();
            }
        }
    }
}
````

## 函数对象

### 1、行为参数化

如果针对一组学生，筛选出男学生，采用下面的代码实现

````java
public class Sample05 {
    public static void main(String[] args) {
        List<Student> students = List.of(
                new Student("张无忌", 18, "男"),
                new Student("杨不悔", 16, "女"),
                new Student("周芷若", 19, "女"),
                new Student("宋青书", 20, "男")
        );

        System.out.println(filter(students)); // 能得到 张无忌，宋青书
    }

    // 过滤，筛选出男学生
    static List<Student> filter(List<Student> students) {
        List<Student> result = new ArrayList<>();
        for (Student student : students) {
            if (student.sex.equals("男")) {
                result.add(student);
            }
        }
        return result;
    }
    // 学生类
    @Data
    @AllArgsConstructor
    static class Student {
        private String name;
        private int age;
        private String sex;
    }
}
````

如果需求变动，需要找到 18 岁以下的学生，上面的代码显然不能用了，需要修改为：

````java
static List<Student> filter(List<Student> students) {
    List<Student> result = new ArrayList<>();
    for (Student student : students) {
        if (student.age <= 18) {
            result.add(student);
        }
    }
    return result;
}
````

如果需求还是需要修改，则每次都需要修改函数内的具体实现逻辑，是否可以通过一个方法实现处理各种情况的呢？其实仔细观察，可以得到这两个方法有共同点，只是筛选的逻辑不一样而已：

````java
interface Lambda {
    boolean test(Student student);
}
````

可以将其抽象位方法，具体实现时再去写逻辑：

````java
static List<Student> filter(List<Student> students, Lambda lambda) {
    List<Student> result = new ArrayList<>();
    for (Student student : students) {
        if (lambda.test(student)) {
            result.add(student);
        }
    }
    return result;
}
````

最后的实现则为：

````java
filter(students, student -> student.sex.equals("男"));
filter(students, student -> student.age <= 18);
filter(students, student -> student.sex.equals("男") && student.age <= 18);
````

这样就实现了以不变应万变，而变换即是一个个函数对象，也可以称之为行为参数化。

### 2、延迟执行

在记录日志时，比如：

````java
static Logger logger = LogManager.getLogger();

public static void main(String[] args) {
    System.out.println(logger.getLevel());
    logger.debug("{}", expensive());
}

static String expensive() {
    System.out.println("执行耗时操作");
    return "结果";
}
````

本来不想要记录日志，但是还是记录日志了，虽然可以通过：

````java
if(logger.isDebugEnabled())
    logger.debug("{}", expensive());
````

改进，但是每次都需要加上 if 判断，很不优雅，可以在 debug 方法外面再嵌套一层：

````java
public void debug(final String msg, final Supplier<?> lambda) {
    if (this.isDebugEnabled()) {
        this.debug(msg, lambda.get());
    }
}
````

调用时为：

````java
logger.debug("{}", () -> expensive());
````

就不会立刻执行，而是在未来 if 条件成立时才执行。
